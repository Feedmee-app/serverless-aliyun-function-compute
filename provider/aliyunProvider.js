'use strict';

const path = require('path');
const fs = require('fs');
const os = require('os');
const ini = require('ini');
const co = require('co');

const BbPromise = require('bluebird');
const _ = require('lodash');

const FCClient = require('@alicloud/fc');
const OSS = require('ali-oss');
const CloudAPI = require('@alicloud/cloudapi');
const RAM = require('@alicloud/ram');

const utils = require('../shared/utils');

const constants = {
  providerName: 'aliyun',
};

const keySym = Symbol('key');
const fcClientSym = Symbol('fc-client');
const agClientSym = Symbol('ag-client');
const ossClientSym = Symbol('oss-client');
const ramClientSym = Symbol('ram-client');

class AliyunProvider {
  static getProviderName() {
    return constants.providerName;
  }

  constructor(serverless, options) {
    this.serverless = serverless;
    this.provider = this;
    this.serverless.setProvider(constants.providerName, this);
    this.options = options;
    utils.setDefaults.call(this);
  }

  get key() {
    if (this[keySym]) {
      return this[keySym];
    }
    let credentials = this.serverless.service.provider.credentials;
    const credParts = credentials.split(path.sep);

    if (credParts[0] === '~') {
      credParts[0] = os.homedir();
      credentials = credParts.reduce((memo, part) => path.join(memo, part), '');
    }
    const keyFileContent = fs.readFileSync(credentials, 'utf-8').toString();
    // TODO(joyeecheung) support profiles other than [default]
    this[keySym] = ini.parse(keyFileContent).default;

    [
      'aliyun_account_id',
      'aliyun_access_key_id',
      'aliyun_access_key_secret'
    ].forEach((field) => {
      if (!this[keySym][field]) {
        throw new Error(`Credentials in ${credentials} does not contain ${field}`);
      }
    });

    return this[keySym];
  }

  get fcClient() {
    if (this[fcClientSym]) {
      return this[fcClientSym];
    }

    const key = this.key;
    this[fcClientSym] = new FCClient(key.aliyun_account_id, {
      accessKeyID: key.aliyun_access_key_id,
      accessKeySecret: key.aliyun_access_key_secret,
      region: this.options.region
    });
    return this[fcClientSym];
  }

  get agClient() {
    if (this[agClientSym]) {
      return this[agClientSym];
    }

    const key = this.key;
    this[agClientSym] = new CloudAPI({
      accessKeyId: key.aliyun_access_key_id,
      accessKeySecret: key.aliyun_access_key_secret,
      endpoint: `http://apigateway.${this.options.region}.aliyuncs.com`
    });
    return this[agClientSym];
  }

  get ramClient() {
    if (this[ramClientSym]) {
      return this[ramClientSym];
    }

    const key = this.key;
    this[ramClientSym] = new RAM({
      accessKeyId: key.aliyun_access_key_id,
      accessKeySecret: key.aliyun_access_key_secret,
      endpoint: 'https://ram.aliyuncs.com'
    });
    return this[ramClientSym];
  }

  get ossClient() {
    if (this[ossClientSym]) {
      return this[ossClientSym];
    }

    const key = this.key;
    this[ossClientSym] = OSS({
      accessKeyId: key.aliyun_access_key_id,
      accessKeySecret: key.aliyun_access_key_secret,
      region: this.getOssRegion()
    });
    return this[ossClientSym];
  }

  resetOssClient(bucketName) {
    const key = this.key;
    this[ossClientSym] = OSS({
      accessKeyId: key.aliyun_access_key_id,
      accessKeySecret: key.aliyun_access_key_secret,
      bucket: bucketName,
      region: this.getOssRegion()
    });
    return this[ossClientSym];
  }

  getStorageBucketId() {
    return "sls-storage-bucket";
  }

  getOssRegion(region) {
    return `oss-${this.options.region}`;
  }

  getStorageObjectId() {
    return "sls-storage-object";
  }

  getServiceId() {
    return "sls-function-service";
  }

  getServiceName() {
    return `${this.serverless.service.service}-${this.options.stage}`;
  }

  getApiGroupLogicalId() {
    return "sls-api-group";
  }

  getInvokeRoleLogicalId() {
    return "sls-fc-invoke-role";
  }

  getApiGroupName() {
    return `${this.getServiceName()}-api`.replace(/-/g, '_');
  }

  getDeploymentBucketName() {
    const service = this.serverless.service.service;
    return `sls-${service}`;
  }

  // If a function is going to be reused by multiple endpoints,
  // the user should create multiple functions instead
  // So the API name is identified by just
  // eventType and funcName
  getApiName(eventType, funcName) {
    return `sls-${eventType}-${funcName}`.replace(/-/g, '_');
  }

  getFunctionLogicalId(name) {
    return `sls-${name}`;
  }

  getApiGroupDesc() {
    const service = this.getServiceName()
    return `API group for Function Compute service ${service}, generated by ` +
           'the Serverless framework.';
  }

  getApiDesc(eventType, funcName) {
    const service = this.getServiceName()
    return `API for Function Compute function ${funcName} of service ` +
           `${service}, triggered by ${eventType} event, generated by the ` +
           'Serverless framework.';
  }

  isApiType(type) {
    return type === "ALIYUN::API::HTTP";
  }

  isFunctionType(type) {
    return type === "ALIYUN::FC::Function";
  }

  getArtifactDirectoryPrefix() {
    const service = this.serverless.service.service;
    const stage = this.options.stage;
    return `serverless/${service}/${stage}`;
  }

  getArtifactDirectoryName() {
    const prefix = this.getArtifactDirectoryPrefix();
    const date = new Date();
    const dateString = `${date.getTime().toString()}-${date.toISOString()}`;

    return `${prefix}/${dateString}`;
  }

  initializeTemplate() {
    const deploymentTemplate = this.serverless.utils.readFileSync(
      path.join(
        __dirname,
        'templates',
        'core-configuration-template.json'));
    
    this.serverless.service.provider.compiledConfigurationTemplate = deploymentTemplate;
    return deploymentTemplate;
  }

  getStorageBucketResource() {
    return {
      "Type": "ALIYUN::OSS:Bucket",
      "Properties": {
        "BucketName": this.getDeploymentBucketName(),
        "Region": this.options.region
      }
    };
  }

  getServiceResource() {
    return {
      "Type": "ALIYUN::FC::Service",
      "Properties": {
        "name": this.getServiceName(),
        "region": this.options.region
      }
    };
  }

  getFunctionResource(funcObject) {
    // Function-wise setting > service-wise setting > default
    const service = this.serverless.service;
    const memorySize = funcObject.memorySize
      || service.provider.memorySize
      || 128;
    const timeout = funcObject.timeout
      || service.provider.timeout
      || 30;

    // TODO(joyeecheung): description
    return {
      "Type": "ALIYUN::FC::Function",
      "Properties": {
        "name": funcObject.name,
        "service": this.getServiceName(),
        "handler": funcObject.handler,
        "memorySize": memorySize,
        "timeout": timeout,
        "runtime": "nodejs4.4",
        "code": {
          "ossBucketName": this.getDeploymentBucketName(),
          "ossObjectName": service.package.artifactFilePath
        }
      }
    }
  }

  getRequestConfig(eventType, event) {
    const path = event.RequestPath || event.path;
    const requestPath = path.startsWith('/') ? path : `/${path}`;
    return {
      "RequestProtocol": eventType.toUpperCase(),
      "RequestHttpMethod": (event.RequestHttpMethod || event.method || "GET").toUpperCase(),
      "RequestPath": requestPath,
      "BodyFormat": (event.BodyFormat || event.bodyFormat || '').toUpperCase(),
      "PostBodyDescription": ""
    };
  }

  getServiceConfig(event, funcObject) {
    return {
      "ServiceProtocol": "FunctionCompute",
      "Mock": "FALSE",
      "ServiceTimeout": 3000,  // TODO(joyeecheung): use config?
      "FunctionComputeConfig": {
        "FcRegionId": this.options.region,
        "ServiceName": this.getServiceName(),
        "FunctionName": funcObject.name,
        "RoleArn": undefined
      },
      "ContentTypeValue": event.ContentTypeValue || "application/json; charset=UTF-8"
    };
  }

  getType(type) {
    const dict = {
      string: 'String',
      number: 'Number'
    };
    return dict[type.toLowerCase()];
  }

  getLocation(loc) {
    const dict = {
      head: 'Head',
      query: 'Query',
      path: 'Path',
      body: 'Body',
    };
    return dict[loc.toLowerCase()];
  }

  getRequestParameters(event) {
    let result = [];
    if (event.parameters) {
      result = event.parameters.map((p) => ({
        ApiParameterName: p.name,
        ParameterType: this.getType(p.type),
        Location: this.getLocation(p.location),
        Required: p.optional ? 'OPTIONAL' : 'REQUIRED',
        isHide: false,  // do not support hidden params
        DefaultValue: p.default,
        DemoValue: p.demo,
        Description: p.description || ''
      }));
    }
    if (event.RequestParameters) {
      result = result.concat(event.RequestParameters);
    }
    return result;
  }

  getServiceParameters(event) {
    let result = [];
    if (event.parameters) {
      result = event.parameters.map((p) => ({
        ServiceParameterName: p.name,
        Type: this.getType(p.type),
        Location: this.getLocation(p.location),
        ParameterCatalog: 'REQUEST'
      }));
    }
    if (event.ServiceParameters) {
      result = result.concat(event.ServiceParameters);
    }
    return result;
  }

  getServiceParametersMap(event) {
    let result = [];
    if (event.parameters) {
      result = event.parameters.map((p) => ({
        ServiceParameterName: p.name,
        RequestParameterName: p.name
      }));
    }
    if (event.ServiceParametersMap) {
      result = result.concat(event.ServiceParametersMap);
    }
    return result;
  }

  getHttpApiResource(event, funcObject) {
    const eventType = 'http';
    return {
      "Type": "ALIYUN::API::HTTP",
      "Properties": {
        "GroupName": this.getApiGroupName(),
        "GroupId": undefined,
        "ApiName": this.getApiName(eventType, funcObject.name),
        "Visibility": event.Visibility || "PUBLIC",
        "Description": this.getApiDesc(eventType, funcObject.name),
        "AuthType": event.AuthType || "ANONYMOUS",
        "RequestConfig": this.getRequestConfig(eventType, event),
        "ServiceConfig": this.getServiceConfig(event, funcObject),
        "RequestParameters": this.getRequestParameters(event),
        "ServiceParameters": this.getServiceParameters(event),
        "ServiceParametersMap": this.getServiceParametersMap(event),
        "ResultType": event.ResultType || "JSON",
        "ResultSample": event.ResultSample || "{}"
      }
    };
  }

  getApiGroupResource() {
    return {
      "Type": "ALIYUN::API::APIGroup",
      "Properties": {
        "GroupName": this.getApiGroupName(),
        "Description": this.getApiGroupDesc(),
        "Region": this.options.region,
        "GroupId": undefined,
        "SubDomain": undefined
      }
    };
  }

  getServiceResource() {
    // TODO(joyeecheung): description
    return {
      "Type": "ALIYUN::FC::Service",
      "Properties": {
        "name": this.getServiceName(),
        "region": this.options.region,
        "id": undefined
      }
    };
  }

  getObjectResource(objectName, localPath) {
    return {
      "Type": "ALIYUN::OSS:Object",
      "Properties": {
        "BucketName": this.getDeploymentBucketName(),
        "ObjectName": objectName,
        "LocalPath": localPath
      }
    }
  }

  getInvokeRoleName() {
    const service = this.getServiceName();
    const roleName = `sls-${service}-invoke-role`.replace(/_/g, '-');
    return roleName;
  }

  getInvokeRoleResource() {
    const service = this.getServiceName();
    const roleName = this.getInvokeRoleName();
    return {
      "Type": "ALIYUN::RAM::Role",
      "Properties": {
        "RoleName": roleName,
        "Description": "Allow Function Compute Service " + service +
          " to be triggered, generated by the Serverless framework",
        // This role can be accessed by API gateway
        "AssumeRolePolicyDocument": {
          "Version": "1",
          "Statement": []
        },
        // This role has the predefined fc invocation policy attached
        "Policies": [{
          "PolicyType": "System",
          "PolicyName": "AliyunFCInvocationAccess",  // predefined
          "RoleName": roleName
        }]
      }
    };
  }

  getApiRoleStatement() {
    return {
      "Action": "sts:AssumeRole",
      "Effect": "Allow",
      "Principal": {
        "Service": [
          "apigateway.aliyuncs.com"
        ]
      }
    };
  }

  makeApiRole(resource) {
    const assume = resource.Properties.AssumeRolePolicyDocument.Statement;
    const apiStatement = this.getApiRoleStatement();
    const foundStatement = assume.find((item) => _.isEqual(apiStatement));
    if (!foundStatement) {
      assume.push(apiStatement);
    }
  }

  /**
   * @param {string} bucketName
   * @returns {{name: string, region: string, creationDate: string}}
   */
  getBucket(bucketName) {
    // TODO(joyeecheung): handle buckets with the same name
    // in a different region
    const ossClient = this.ossClient;
    return co(function *getBucket() {
      const res = yield ossClient.listBuckets({ prefix: bucketName });
      if (!res.buckets) return undefined;
      const bucket = res.buckets.find((b) => b.name === bucketName);
      return bucket;
    });
  }

  /**
   * @param {string} bucketName 
   */
  createBucket(bucketName) {
    const ossClient = this.ossClient;
    const region = this.getOssRegion();
    return co(function *createBucket() {
      return yield ossClient.putBucket(bucketName, region)
    });
  }

  /**
   * @param {string} bucketName 
   */
  deleteBucket(bucketName) {
    const ossClient = this.ossClient;
    const region = this.getOssRegion();
    return co(function *deleteBucket() {
      return yield ossClient.deleteBucket(bucketName, region)
    });
  }

  uploadObject(objectName, filePath) {
    const ossClient = this.ossClient;
    return co(function *uploadObject() {
      return yield ossClient.put(objectName, filePath)
    });
  }

  deleteObjects(objectNames) {
    const ossClient = this.ossClient;
    return co(function *deleteObjects() {
      // TODO(joyeecheung): handle partial failures
      return yield ossClient.deleteMulti(objectNames)
    });
  }

  /**
   * 
   * @param {object} props 
   */
  getObjects(props) {
    // TODO(joyeecheung): handle >= 1000 objects
    const ossClient = this.ossClient;
    const query = Object.assign({ 'max-keys': 999 }, props);
    return co(function *listObjects() {
      const res = yield ossClient.list(query);
      return res.objects || [];
    });
  }

  // http://doxmate.cool/aliyun/fc-nodejs-sdk/api.html

  /**
   * @param {string} serviceName
   * @return {ServiceResponse}
   */
  getService(serviceName) {
    return this.fcClient.getService(serviceName)
      .catch((err) => {
        if (err.code === 'ServiceNotFound') return undefined;
        throw err;
      });
  }

  /**
   * @param {string} serviceName
   * @param {{description: string}} options
   * @return {ServiceResponse}
   * https://help.aliyun.com/document_detail/52877.html#service
   * https://help.aliyun.com/document_detail/52877.html#serviceresponse
   */
  createService(serviceName, options) {
    return this.fcClient.createService(serviceName, options);
  }

  deleteService(serviceName, options) {
    return this.fcClient.deleteService(serviceName, options);
  }

  /**
   * @param {string} serviceName
   * @param {Service} options
   * @return {ServiceResponse}
   */
  updateService(serviceName, options) {
    return this.fcClient.updateService(serviceName, options);
  }

  /**
   * @param {string} serviceName
   * @param {string} functionName
   * @return {FunctionResponse}
   */
  getFunction(serviceName, functionName) {
    return this.fcClient.getFunction(serviceName, functionName)
      .catch((err) => {
        if (err.code === 'FunctionNotFound') return undefined;
        throw err;
      });
  }

  /**
   * @param {string} serviceName
   * @param {string} funcName
   * @param {Function} options
   * @return {FunctionResponse}
   * https://help.aliyun.com/document_detail/52877.html#function
   * https://help.aliyun.com/document_detail/52877.html#functionresponse
   */
  createFunction(serviceName, functionName, options) {
    const config = Object.assign({ functionName }, options);
    return this.fcClient.createFunction(serviceName, config);
  }

  /**
   * @param {string} serviceName
   * @param {string} functionName
   * @param {Function} options
   * @return {FunctionResponse}
   */
  updateFunction(serviceName, functionName, options) {
    const config = Object.assign({ functionName }, options);
    return this.fcClient.updateFunction(serviceName, functionName, config);
  }

  /**
   * @param {string} serviceName
   * @return {{functionName: string, functionId: string}}
   * TODO(joyeecheung): paging
   */
  getFunctions(serviceName) {
    return this.fcClient.listFunctions(serviceName).then((res) => {
      const functions = res.functions;
      if (!functions) return [];
      return functions;
    });
  }

  /**
   * @param {string} serviceName
   * @param {string} functionName
   * @return {object}
   */
  deleteFunction(serviceName, functionName) {
    return this.fcClient.deleteFunction(serviceName, functionName);
  }

  /**
   * @param {string} serviceName
   * @param {string} functionName
   * @param {Event} event
   * @return {InvokeResponse}
   * https://help.aliyun.com/document_detail/52877.html#invokeresponse
   */
  invokeFunction(serviceName, functionName, event) {
    return this.fcClient.invokeFunction(serviceName, functionName, event);
  }

  /**
   * @param {string} serviceName
   * @param {string} functionName
   * @param {Trigger} trigger
   * @return {TriggerResponse}https://help.aliyun.com/document_detail/52877.html#trigger
   * https://help.aliyun.com/document_detail/52877.html#triggerresponse
   */
  createTrigger(serviceName, functionName, trigger) {
    return this.fcClient.createTrigger(serviceName, functionName, trigger);
  }

  /**
   * @param {string} serviceName
   * @param {string} functionName
   * @param {string} triggerName
   * @return {TriggerResponse}
   */
  getTrigger(serviceName, functionName, triggerName) {
    return this.fcClient.getTrigger(serviceName, functionName, triggerName);
  }

  /**
   * @param {string} serviceName
   * @param {string} functionName
   * @param {string} triggerName
   * @param {Trigger} trigger
   * @return {TriggerResponse}
   */
  updateTrigger(serviceName, functionName, triggerName, trigger) {
    return this.fcClient.createTrigger(serviceName, functionName, triggerName, trigger);
  }

  /**
   * @param {string} serviceName
   * @param {string} functionName
   * @param {string} triggerName
   * @return {}
   */
  deleteTrigger(serviceName, functionName, triggerName) {
    return this.fcClient.deleteTrigger(serviceName, functionName, triggerName);
  }

  // https://help.aliyun.com/document_detail/43595.html

  /**
   * @param {string} groupName
   * @return {{GroupId: string, GroupName: string, SubDomain: string}}
   * https://help.aliyun.com/document_detail/43616.html
   */
  getApiGroup(groupName) {
    // TODO(joyeecheung): pagination
    return this.agClient.describeApiGroups({
      GroupName: groupName
    }).then((res) => {
      if (res.TotalCount === 0) {
        return undefined;
      }
      const groups = res.ApiGroupAttributes.ApiGroupAttribute;
      const group = groups.find(
        (item) => item.GroupName === groupName);
      return group;
    });
  }

  /**
   * @param {{GroupId: string}} group
   * https://help.aliyun.com/document_detail/43617.html
   */
  deleteApiGroup(group) {
    return this.agClient.deleteApiGroup(group);
  }

  /**
   * @param {{GroupName: string, Description: string}} props
   * @return {{GroupId: string, GroupName: string, SubDomain: string}}
   * https://help.aliyun.com/document_detail/43611.html
   */
  createApiGroup(props) {
    return this.agClient.createApiGroup(props);
  }

  /**
   * @param {string} roleName
   * @return {{RoleId: string, RoleName: string, Arn: string}}
   * https://help.aliyun.com/document_detail/28711.html
   */
  getRole(roleName) {
    return this.ramClient.getRole({
      RoleName: roleName
    }).then(
      (res) => res.Role,
      (err) => {
        if (err.name === 'EntityNotExist.RoleError') return undefined;
        throw err;
      }
    );
  }

  deleteRole(roleName) {
    return this.ramClient.deleteRole({
      RoleName: roleName
    });
  }

  /**
   * @param {object} role
   * @return {{RoleId: string, RoleName: string, Arn: string}}
   * https://help.aliyun.com/document_detail/28710.html 
   */
  createRole(role) {
    return this.ramClient.createRole({
      RoleName: role.RoleName,
      Description: role.Description,
      AssumeRolePolicyDocument: JSON.stringify(role.AssumeRolePolicyDocument)
    }).then((res) => res.Role);
  }

  /**
   * @param {string} roleName
   * @return {{PolicyName: string}[]}
   */
  getPoliciesForRole(roleName) {
    return this.ramClient.listPoliciesForRole({
      RoleName: roleName
    }).then((res) => res.Policies.Policy);
  }

  /**
   * @param {{PolicyName: string, PolicyType: string, RoleName: string}} policy
   * @return {{PolicyName: string}[]}
   */
  attachPolicyToRole(policy) {
    return this.ramClient.attachPolicyToRole(policy);
  }

  /**
   * @param {{PolicyName: string, PolicyType: string, RoleName: string}} plicy
   */
  detachPolicyFromRole(role, policy) {
    return this.ramClient.detachPolicyFromRole({
      RoleName: role.RoleName,
      PolicyName: policy.PolicyName,
      PolicyType: policy.PolicyType
    });
  }

  /**
   * @param {{GroupId: string}} props 
   * @returns {{GroupId: string, ApiName: string, ApiId: string}[]} 
   * https://help.aliyun.com/document_detail/43626.html
   */
  getApis(props) {
    const query = Object.assign({}, props, { PageSize: 50 });
    return this.agClient.describeApis(query)
      .then((res) => {
        if (!res.ApiSummarys) return [];
        const apis = res.ApiSummarys.ApiSummary;
        if (res.TotalCount > apis.length) {
          // TODO(joyeecheung): pagination
        }
        return apis;
      });
  }

  /**
   * https://help.aliyun.com/document_detail/43625.html
   */
  getApi(group, api) {
    const query = {
      GroupId: group.GroupId,
      ApiId: api.ApiId
    };
    return this.agClient.describeApi(query);
  }

  getApiProps(group, role, api) {
    const toStringify = ['RequestConfig', 'ServiceConfig',
      'RequestParameters', 'ServiceParameters', 'ServiceParametersMap'];
    const props = _.cloneDeep(api);
    props.ServiceConfig.FunctionComputeConfig.RoleArn = role.Arn;
    props.GroupId = group.GroupId;
    toStringify.forEach((key) => {
      props[key] = JSON.stringify(props[key]);
    });
    return props;
  }

  /**
   * @param {object} props
   * https://help.aliyun.com/document_detail/43623.html
   */
  createApi(group, role, api) {
    const props = this.getApiProps(group, role, api);
    return this.agClient.createApi(props);
  }

  /**
   * 
   * @param {{GroupId: string}} group 
   * @param {{ApiId: string}} api 
   * https://help.aliyun.com/document_detail/43639.html
   */
  deleteApi(group, api) {
    const props = {
      GroupId: group.GroupId,
      ApiId: api.ApiId
    };
    return this.agClient.deleteApi(props);
  }

  /**
   * @param {object} props
   * https://help.aliyun.com/document_detail/43623.html
   */
  updateApi(group, role, api) {
    const props = this.getApiProps(group, role, api);
    return this.agClient.modifyApi(props);
  }

  deployApi(group, api) {
    const props = {
      GroupId: group.GroupId,
      ApiId: api.ApiId,
      StageName: "RELEASE",  // TODO(joyeecheung): should be based on this.options.stage?
      Description: "Release by the Serverless framework"
    };
    return this.agClient.deployApi(props);
  }

  /**
   * @param {{GroupId: string}} props 
   * @returns {{GroupId: string, ApiName: string, ApiId: string}[]}
   */
  getDeployedApis(props) {
    const query = {
      GroupId: props.GroupId,
      StageName: "RELEASE",  // TODO(joyeecheung): should be based on this.options.stage?
      PageSize: 50  // TODO(joyeecheung): pagination
    };
    return this.agClient.describeDeployedApis(query)
      .then((res) => {
        if (!res.DeployedApis) return [];
        const apis = res.DeployedApis.DeployedApiItem;
        if (res.TotalCount > apis.length) {
          // TODO(joyeecheung): pagination
        }
        return apis.filter((item) => item.RegionId === this.options.region);
      });
  }

  abolishApi(group, api) {
    const props = {
      GroupId: group.GroupId,
      ApiId: api.ApiId,
      StageName: "RELEASE",  // TODO(joyeecheung): should be based on this.options.stage?
    };
    return this.agClient.abolishApi(props);
  }
}

module.exports = AliyunProvider;
